import smbus2
import time
import numpy as np
from collections import deque
from dataclasses import dataclass
from typing import Tuple

@dataclass
class Vector3D:
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0
    
    def __add__(self, other):
        return Vector3D(self.x + other.x, self.y + other.y, self.z + other.z)
    
    def __sub__(self, other):
        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)
    
    def __mul__(self, scalar):
        return Vector3D(self.x * scalar, self.y * scalar, self.z * scalar)
    
    def magnitude(self):
        return np.sqrt(self.x**2 + self.y**2 + self.z**2)
    
    def to_array(self):
        return np.array([self.x, self.y, self.z])

class MPU6050:
    """MPU6050 IMU interface"""
    
    PWR_MGMT_1 = 0x6B
    ACCEL_XOUT_H = 0x3B
    GYRO_XOUT_H = 0x43
    ACCEL_SCALE = 16384.0
    GYRO_SCALE = 131.0
    
    def __init__(self, bus_num=1, address=0x68):
        self.bus = smbus2.SMBus(bus_num)
        self.address = address
        self._initialize()
    
    def _initialize(self):
        self.bus.write_byte_data(self.address, self.PWR_MGMT_1, 0)
        time.sleep(0.1)
    
    def read_raw_data(self, reg):
        high = self.bus.read_byte_data(self.address, reg)
        low = self.bus.read_byte_data(self.address, reg + 1)
        value = (high << 8) | low
        if value > 32768:
            value -= 65536
        return value
    
    def read_accel(self) -> Vector3D:
        ax = self.read_raw_data(self.ACCEL_XOUT_H) / self.ACCEL_SCALE
        ay = self.read_raw_data(self.ACCEL_XOUT_H + 2) / self.ACCEL_SCALE
        az = self.read_raw_data(self.ACCEL_XOUT_H + 4) / self.ACCEL_SCALE
        return Vector3D(ax, ay, az)
    
    def read_gyro(self) -> Vector3D:
        gx = self.read_raw_data(self.GYRO_XOUT_H) / self.GYRO_SCALE
        gy = self.read_raw_data(self.GYRO_XOUT_H + 2) / self.GYRO_SCALE
        gz = self.read_raw_data(self.GYRO_XOUT_H + 4) / self.GYRO_SCALE
        return Vector3D(gx, gy, gz)

class ComplementaryFilter:
    """Complementary filter for sensor fusion"""
    
    def __init__(self, alpha=0.98):
        self.alpha = alpha
        self.angle = Vector3D()
    
    def update(self, accel: Vector3D, gyro: Vector3D, dt: float) -> Vector3D:
        # Gyroscope integration
        self.angle.x += gyro.x * dt
        self.angle.y += gyro.y * dt
        self.angle.z += gyro.z * dt
        
        # Accelerometer angles
        accel_angle_x = np.arctan2(accel.y, np.sqrt(accel.x**2 + accel.z**2)) * 180/np.pi
        accel_angle_y = np.arctan2(-accel.x, np.sqrt(accel.y**2 + accel.z**2)) * 180/np.pi
        
        # Complementary filter
        self.angle.x = self.alpha * self.angle.x + (1 - self.alpha) * accel_angle_x
        self.angle.y = self.alpha * self.angle.y + (1 - self.alpha) * accel_angle_y
        
        return self.angle

class KalmanFilter:
    """1D Kalman filter for noise reduction"""
    
    def __init__(self, process_variance=1e-3, measurement_variance=1e-1):
        self.process_variance = process_variance
        self.measurement_variance = measurement_variance
        self.estimate = 0.0
        self.estimate_error = 1.0
    
    def update(self, measurement: float) -> float:
        # Prediction
        prediction_error = self.estimate_error + self.process_variance
        
        # Update
        kalman_gain = prediction_error / (prediction_error + self.measurement_variance)
        self.estimate = self.estimate + kalman_gain * (measurement - self.estimate)
        self.estimate_error = (1 - kalman_gain) * prediction_error
        
        return self.estimate

class MovingAverageFilter:
    """Moving average filter for smoothing"""
    
    def __init__(self, window_size=10):
        self.window_size = window_size
        self.data_x = deque(maxlen=window_size)
        self.data_y = deque(maxlen=window_size)
        self.data_z = deque(maxlen=window_size)
    
    def update(self, vec: Vector3D) -> Vector3D:
        self.data_x.append(vec.x)
        self.data_y.append(vec.y)
        self.data_z.append(vec.z)
        
        return Vector3D(
            sum(self.data_x) / len(self.data_x),
            sum(self.data_y) / len(self.data_y),
            sum(self.data_z) / len(self.data_z)
        )

class StationaryDetector:
    """Detects when the IMU is stationary using ZUPT"""
    
    def __init__(self, accel_threshold=0.002, gyro_threshold=1.5, window_size=15):
        self.accel_threshold = accel_threshold
        self.gyro_threshold = gyro_threshold
        self.window_size = window_size
        
        self.accel_history = deque(maxlen=window_size)
        self.gyro_history = deque(maxlen=window_size)
    
    def update(self, accel: Vector3D, gyro: Vector3D) -> bool:
        self.accel_history.append(accel.magnitude())
        self.gyro_history.append(gyro.magnitude())
        
        if len(self.accel_history) < self.window_size:
            return False
        
        accel_variance = np.var(list(self.accel_history))
        gyro_variance = np.var(list(self.gyro_history))
        
        is_stationary = (accel_variance < self.accel_threshold and 
                        gyro_variance < self.gyro_threshold)
        
        return is_stationary

class RelativePositionTracker:
    """Tracks position relative to starting point with ZUPT drift correction"""
    
    def __init__(self, gravity=9.81):
        self.gravity = gravity
        self.velocity = Vector3D()
        self.position = Vector3D()
        
        # Kalman filters for each axis
        self.kalman_x = KalmanFilter(process_variance=1e-4, measurement_variance=0.1)
        self.kalman_y = KalmanFilter(process_variance=1e-4, measurement_variance=0.1)
        self.kalman_z = KalmanFilter(process_variance=1e-4, measurement_variance=0.1)
        
        # Moving average for smoothing
        self.ma_filter = MovingAverageFilter(window_size=5)
        
        # Stationary detector for ZUPT
        self.stationary_detector = StationaryDetector(
            accel_threshold=0.002,
            gyro_threshold=1.5,
            window_size=15
        )
        
        # Bias calibration
        self.accel_bias = Vector3D()
        self.is_calibrated = False
        
        # ZUPT statistics
        self.zupt_count = 0
        self.is_stationary = False
        self.stationary_duration = 0.0
        
        # Drift correction - estimate velocity bias when stationary
        self.velocity_bias = Vector3D()
        self.bias_update_rate = 0.1  # How quickly to adapt bias estimate
        
        # High-pass filter for drift removal (more aggressive now)
        self.alpha_hp = 0.98
        self.vel_prev = Vector3D()
    
    def calibrate(self, mpu: MPU6050, samples=200):
        """Calibrate by measuring bias while stationary"""
        print("Calibrating... Keep sensor stationary!")
        print("Using more samples for better calibration...")
        bias_sum = Vector3D()
        
        # Discard first few samples (sensor warmup)
        for i in range(10):
            mpu.read_accel()
            time.sleep(0.01)
        
        for i in range(samples):
            accel = mpu.read_accel()
            bias_sum = bias_sum + accel
            if i % 50 == 0:
                print(f"  Calibration progress: {i}/{samples}")
            time.sleep(0.01)
        
        self.accel_bias = Vector3D(
            bias_sum.x / samples,
            bias_sum.y / samples,
            (bias_sum.z / samples) - 1.0  # Remove gravity from z-axis
        )
        self.is_calibrated = True
        print(f"Calibration complete! Bias: X={self.accel_bias.x:.4f}, "
              f"Y={self.accel_bias.y:.4f}, Z={self.accel_bias.z:.4f}")
        
        # Position and velocity start at zero (this is your home position)
        self.velocity = Vector3D()
        self.position = Vector3D()
        print("Home position set to (0, 0, 0)")
    
    def apply_deadzone(self, value: float, threshold=0.015) -> float:
        return value if abs(value) > threshold else 0.0
    
    def update(self, accel: Vector3D, gyro: Vector3D, dt: float) -> Tuple[Vector3D, Vector3D]:
        """Update position relative to starting point"""
        if not self.is_calibrated:
            raise ValueError("Sensor not calibrated! Call calibrate() first.")
        
        # Check if stationary
        was_stationary = self.is_stationary
        self.is_stationary = self.stationary_detector.update(accel, gyro)
        
        if self.is_stationary:
            self.stationary_duration += dt
            
            # When stationary, velocity SHOULD be zero
            # Use this to estimate and correct velocity bias (drift)
            if self.stationary_duration > 0.5:  # After 0.5s of being stationary
                # Gradually correct velocity bias
                self.velocity_bias.x += self.velocity.x * self.bias_update_rate * dt
                self.velocity_bias.y += self.velocity.y * self.bias_update_rate * dt
                self.velocity_bias.z += self.velocity.z * self.bias_update_rate * dt
                
                # Zero out velocity (ZUPT)
                self.velocity = Vector3D(0, 0, 0)
                self.zupt_count += 1
            
            # Don't change position when stationary - it stays where it is
            return self.velocity, self.position
        else:
            # Reset stationary duration when moving
            if was_stationary:
                self.stationary_duration = 0.0
        
        # Remove bias
        accel_corrected = Vector3D(
            accel.x - self.accel_bias.x,
            accel.y - self.accel_bias.y,
            accel.z - self.accel_bias.z
        )
        
        # Apply Kalman filtering
        accel_filtered = Vector3D(
            self.kalman_x.update(accel_corrected.x),
            self.kalman_y.update(accel_corrected.y),
            self.kalman_z.update(accel_corrected.z)
        )
        
        # Apply moving average
        accel_smooth = self.ma_filter.update(accel_filtered)
        
        # Apply deadzone
        accel_clean = Vector3D(
            self.apply_deadzone(accel_smooth.x, threshold=0.015),
            self.apply_deadzone(accel_smooth.y, threshold=0.015),
            self.apply_deadzone(accel_smooth.z, threshold=0.015)
        )
        
        # Convert to m/s²
        accel_ms2 = accel_clean * self.gravity
        
        # Integrate to velocity
        self.velocity = self.velocity + accel_ms2 * dt
        
        # Apply velocity bias correction (learned from stationary periods)
        self.velocity.x -= self.velocity_bias.x * dt * 2.0
        self.velocity.y -= self.velocity_bias.y * dt * 2.0
        self.velocity.z -= self.velocity_bias.z * dt * 2.0
        
        # High-pass filter on velocity to remove DC drift
        hp_filtered = Vector3D(
            self.alpha_hp * (self.vel_prev.x + self.velocity.x - self.vel_prev.x),
            self.alpha_hp * (self.vel_prev.y + self.velocity.y - self.vel_prev.y),
            self.alpha_hp * (self.vel_prev.z + self.velocity.z - self.vel_prev.z)
        )
        self.vel_prev = Vector3D(self.velocity.x, self.velocity.y, self.velocity.z)
        self.velocity = hp_filtered
        
        # Apply velocity deadzone
        self.velocity = Vector3D(
            self.apply_deadzone(self.velocity.x, threshold=0.005),
            self.apply_deadzone(self.velocity.y, threshold=0.005),
            self.apply_deadzone(self.velocity.z, threshold=0.005)
        )
        
        # Integrate to position (relative to starting point)
        self.position = self.position + self.velocity * dt
        
        return self.velocity, self.position
    
    def reset_to_home(self):
        """Reset to home position (0, 0, 0) - useful if drift becomes too large"""
        self.velocity = Vector3D()
        self.position = Vector3D()
        self.velocity_bias = Vector3D()
        self.zupt_count = 0
        print("\n[RESET] Position reset to home (0, 0, 0)")
    
    def set_home(self):
        """Set current position as new home (0, 0, 0)"""
        self.position = Vector3D()
        self.velocity = Vector3D()
        print(f"\n[NEW HOME] Current position set as home (0, 0, 0)")

def main():
    """Main tracking loop"""
    print("MPU6050 Relative Position Tracking System")
    print("=" * 60)
    
    # Initialize MPU6050
    try:
        mpu = MPU6050(bus_num=1, address=0x68)
        print("✓ MPU6050 initialized")
    except Exception as e:
        print(f"✗ Failed to initialize MPU6050: {e}")
        print("Make sure I2C is enabled: sudo raspi-config -> Interface Options -> I2C")
        return
    
    # Initialize position tracker
    tracker = RelativePositionTracker()
    
    # Calibrate sensor - THIS SETS YOUR HOME POSITION
    print("\n⚠️  Place IMU at your desired HOME position before calibrating!")
    input("Press ENTER when ready to calibrate...")
    tracker.calibrate(mpu, samples=200)
    
    # Initialize complementary filter for orientation
    comp_filter = ComplementaryFilter(alpha=0.98)
    
    print("\nStarting relative position tracking...")
    print("Position is relative to calibration point (home)")
    print("When stationary, velocity resets but position stays")
    print("Move right → positive X, Move back → returns toward 0")
    print("\nPress Ctrl+C to stop")
    print("Type 'h' + ENTER during operation to reset home (advanced)")
    print()
    
    last_time = time.time()
    update_counter = 0
    
    try:
        while True:
            # Calculate dt
            current_time = time.time()
            dt = current_time - last_time
            last_time = current_time
            
            # Read sensor data
            accel = mpu.read_accel()
            gyro = mpu.read_gyro()
            
            # Update orientation (for reference)
            angle = comp_filter.update(accel, gyro, dt)
            
            # Update position with ZUPT
            velocity, position = tracker.update(accel, gyro, dt)
            
            # Print status every 10 iterations
            update_counter += 1
            if update_counter >= 10:
                status = "[STATIONARY]" if tracker.is_stationary else "[MOVING]    "
                
                # Add visual indicator if position is getting large (possible drift)
                drift_warning = ""
                if position.magnitude() > 0.5:  # More than 50cm from home
                    drift_warning = " ⚠️ "
                
                print(f"{status} Pos: X={position.x:7.3f}m Y={position.y:7.3f}m Z={position.z:7.3f}m{drift_warning} | "
                      f"Vel: X={velocity.x:6.3f}m/s Y={velocity.y:6.3f}m/s Z={velocity.z:6.3f}m/s | "
                      f"ZUPT: {tracker.zupt_count}", 
                      end='\r')
                update_counter = 0
            
            # Small delay for consistent sampling
            time.sleep(0.01)  # 100 Hz
            
    except KeyboardInterrupt:
        print("\n\nStopping...")
        print(f"\nFinal Position (relative to home):")
        print(f"  X: {position.x:.3f} m")
        print(f"  Y: {position.y:.3f} m")
        print(f"  Z: {position.z:.3f} m")
        print(f"  Distance from home: {position.magnitude():.3f} m")
        print(f"\nZUPT activations: {tracker.zupt_count}")

if __name__ == "__main__":
    main()
