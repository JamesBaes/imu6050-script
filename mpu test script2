
import smbus2
import time
import numpy as np
from collections import deque
from dataclasses import dataclass
from typing import Tuple

@dataclass
class Vector3D:
    x: float = 0.0
    y: float = 0.0
    z: float = 0.0
    
    def __add__(self, other):
        return Vector3D(self.x + other.x, self.y + other.y, self.z + other.z)
    
    def __mul__(self, scalar):
        return Vector3D(self.x * scalar, self.y * scalar, self.z * scalar)
    
    def to_array(self):
        return np.array([self.x, self.y, self.z])

class MPU6050:
    """MPU6050 IMU interface"""
    
    # MPU6050 Registers
    PWR_MGMT_1 = 0x6B
    ACCEL_XOUT_H = 0x3B
    GYRO_XOUT_H = 0x43
    
    # Sensitivity scales
    ACCEL_SCALE = 16384.0  # for ±2g range
    GYRO_SCALE = 131.0     # for ±250°/s range
    
    def __init__(self, bus_num=1, address=0x68):
        self.bus = smbus2.SMBus(bus_num)
        self.address = address
        self._initialize()
    
    def _initialize(self):
        """Wake up MPU6050 and configure"""
        self.bus.write_byte_data(self.address, self.PWR_MGMT_1, 0)
        time.sleep(0.1)
    
    def read_raw_data(self, reg):
        """Read 16-bit signed data from register"""
        high = self.bus.read_byte_data(self.address, reg)
        low = self.bus.read_byte_data(self.address, reg + 1)
        value = (high << 8) | low
        if value > 32768:
            value -= 65536
        return value
    
    def read_accel(self) -> Vector3D:
        """Read accelerometer data in g units"""
        ax = self.read_raw_data(self.ACCEL_XOUT_H) / self.ACCEL_SCALE
        ay = self.read_raw_data(self.ACCEL_XOUT_H + 2) / self.ACCEL_SCALE
        az = self.read_raw_data(self.ACCEL_XOUT_H + 4) / self.ACCEL_SCALE
        return Vector3D(ax, ay, az)
    
    def read_gyro(self) -> Vector3D:
        """Read gyroscope data in degrees/s"""
        gx = self.read_raw_data(self.GYRO_XOUT_H) / self.GYRO_SCALE
        gy = self.read_raw_data(self.GYRO_XOUT_H + 2) / self.GYRO_SCALE
        gz = self.read_raw_data(self.GYRO_XOUT_H + 4) / self.GYRO_SCALE
        return Vector3D(gx, gy, gz)

class ComplementaryFilter:
    """Complementary filter for sensor fusion"""
    
    def __init__(self, alpha=0.98):
        self.alpha = alpha
        self.angle = Vector3D()
    
    def update(self, accel: Vector3D, gyro: Vector3D, dt: float) -> Vector3D:
        """Fuse accelerometer and gyroscope data"""
        # Gyroscope integration
        self.angle.x += gyro.x * dt
        self.angle.y += gyro.y * dt
        self.angle.z += gyro.z * dt
        
        # Accelerometer angles
        accel_angle_x = np.arctan2(accel.y, np.sqrt(accel.x**2 + accel.z**2)) * 180/np.pi
        accel_angle_y = np.arctan2(-accel.x, np.sqrt(accel.y**2 + accel.z**2)) * 180/np.pi
        
        # Complementary filter
        self.angle.x = self.alpha * self.angle.x + (1 - self.alpha) * accel_angle_x
        self.angle.y = self.alpha * self.angle.y + (1 - self.alpha) * accel_angle_y
        
        return self.angle

class KalmanFilter:
    """1D Kalman filter for noise reduction"""
    
    def __init__(self, process_variance=1e-3, measurement_variance=1e-1):
        self.process_variance = process_variance
        self.measurement_variance = measurement_variance
        self.estimate = 0.0
        self.estimate_error = 1.0
    
    def update(self, measurement: float) -> float:
        """Update filter with new measurement"""
        # Prediction
        prediction_error = self.estimate_error + self.process_variance
        
        # Update
        kalman_gain = prediction_error / (prediction_error + self.measurement_variance)
        self.estimate = self.estimate + kalman_gain * (measurement - self.estimate)
        self.estimate_error = (1 - kalman_gain) * prediction_error
        
        return self.estimate

class MovingAverageFilter:
    """Moving average filter for smoothing"""
    
    def __init__(self, window_size=10):
        self.window_size = window_size
        self.data_x = deque(maxlen=window_size)
        self.data_y = deque(maxlen=window_size)
        self.data_z = deque(maxlen=window_size)
    
    def update(self, vec: Vector3D) -> Vector3D:
        """Add new data and return filtered value"""
        self.data_x.append(vec.x)
        self.data_y.append(vec.y)
        self.data_z.append(vec.z)
        
        return Vector3D(
            sum(self.data_x) / len(self.data_x),
            sum(self.data_y) / len(self.data_y),
            sum(self.data_z) / len(self.data_z)
        )

class PositionTracker:
    """Integrates acceleration to velocity and position"""
    
    def __init__(self, gravity=9.81):
        self.gravity = gravity
        self.velocity = Vector3D()
        self.position = Vector3D()
        
        # Kalman filters for each axis
        self.kalman_x = KalmanFilter(process_variance=1e-4, measurement_variance=0.1)
        self.kalman_y = KalmanFilter(process_variance=1e-4, measurement_variance=0.1)
        self.kalman_z = KalmanFilter(process_variance=1e-4, measurement_variance=0.1)
        
        # Moving average for smoothing
        self.ma_filter = MovingAverageFilter(window_size=5)
        
        # Bias calibration
        self.accel_bias = Vector3D()
        self.is_calibrated = False
    
    def calibrate(self, mpu: MPU6050, samples=100):
        """Calibrate by measuring bias while stationary"""
        print("Calibrating... Keep sensor stationary!")
        bias_sum = Vector3D()
        
        for i in range(samples):
            accel = mpu.read_accel()
            bias_sum = bias_sum + accel
            time.sleep(0.01)
        
        self.accel_bias = Vector3D(
            bias_sum.x / samples,
            bias_sum.y / samples,
            (bias_sum.z / samples) - 1.0  # Remove gravity from z-axis
        )
        self.is_calibrated = True
        print(f"Calibration complete! Bias: X={self.accel_bias.x:.4f}, "
              f"Y={self.accel_bias.y:.4f}, Z={self.accel_bias.z:.4f}")
    
    def apply_deadzone(self, value: float, threshold=0.05) -> float:
        """Apply deadzone to reduce drift from small values"""
        return value if abs(value) > threshold else 0.0
    
    def update(self, accel: Vector3D, dt: float) -> Tuple[Vector3D, Vector3D]:
        """Update position using double integration of acceleration"""
        if not self.is_calibrated:
            raise ValueError("Sensor not calibrated! Call calibrate() first.")
        
        # Remove bias
        accel_corrected = Vector3D(
            accel.x - self.accel_bias.x,
            accel.y - self.accel_bias.y,
            accel.z - self.accel_bias.z
        )
        
        # Apply Kalman filtering
        accel_filtered = Vector3D(
            self.kalman_x.update(accel_corrected.x),
            self.kalman_y.update(accel_corrected.y),
            self.kalman_z.update(accel_corrected.z)
        )
        
        # Apply moving average
        accel_smooth = self.ma_filter.update(accel_filtered)
        
        # Apply deadzone to reduce drift
        accel_clean = Vector3D(
            self.apply_deadzone(accel_smooth.x),
            self.apply_deadzone(accel_smooth.y),
            self.apply_deadzone(accel_smooth.z)
        )
        
        # Convert to m/s²
        accel_ms2 = accel_clean * self.gravity
        
        # Kinematics: v = v0 + a*dt
        self.velocity = self.velocity + accel_ms2 * dt
        
        # Kinematics: s = s0 + v*dt + 0.5*a*dt²
        self.position = self.position + self.velocity * dt + accel_ms2 * (0.5 * dt * dt)
        
        return self.velocity, self.position
    
    def reset(self):
        """Reset velocity and position to zero"""
        self.velocity = Vector3D()
        self.position = Vector3D()
        print("Position and velocity reset to zero")

def main():
    """Main tracking loop"""
    print("MPU6050 Position Tracking System")
    print("=" * 50)
    
    # Initialize MPU6050
    try:
        mpu = MPU6050(bus_num=1, address=0x68)
        print("✓ MPU6050 initialized")
    except Exception as e:
        print(f"✗ Failed to initialize MPU6050: {e}")
        print("Make sure I2C is enabled: sudo raspi-config -> Interface Options -> I2C")
        return
    
    # Initialize position tracker
    tracker = PositionTracker()
    
    # Calibrate sensor
    tracker.calibrate(mpu, samples=100)
    
    # Initialize complementary filter for orientation
    comp_filter = ComplementaryFilter(alpha=0.98)
    
    print("\nStarting position tracking...")
    print("Press Ctrl+C to stop\n")
    
    last_time = time.time()
    update_counter = 0
    
    try:
        while True:
            # Calculate dt
            current_time = time.time()
            dt = current_time - last_time
            last_time = current_time
            
            # Read sensor data
            accel = mpu.read_accel()
            gyro = mpu.read_gyro()
            
            # Update orientation (for reference)
            angle = comp_filter.update(accel, gyro, dt)
            
            # Update position
            velocity, position = tracker.update(accel, dt)
            
            # Print status every 10 iterations
            update_counter += 1
            if update_counter >= 10:
                print(f"Position: X={position.x:8.3f}m  Y={position.y:8.3f}m  Z={position.z:8.3f}m  |  "
                      f"Velocity: X={velocity.x:7.3f}m/s  Y={velocity.y:7.3f}m/s  Z={velocity.z:7.3f}m/s", 
                      end='\r')
                update_counter = 0
            
            # Small delay for consistent sampling
            time.sleep(0.01)  # 100 Hz
            
    except KeyboardInterrupt:
        print("\n\nStopping...")
        print(f"\nFinal Position:")
        print(f"  X: {position.x:.3f} m")
        print(f"  Y: {position.y:.3f} m")
        print(f"  Z: {position.z:.3f} m")

if __name__ == "__main__":
    main()
